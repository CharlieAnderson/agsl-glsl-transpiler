// AGSL "Torture Test"
// Purpose: Verify the transpiler handles Android-specific syntax correctly.

// TEST 1: Layout Qualifiers
// The transpiler must strip 'layout(color)' or WebGL will crash.
// Note: Since we don't have UI sliders yet, this defaults to (0,0,0,0) transparent.

layout(color) uniform half4 uBrandColor;

half4 main(float2 coord) {
    // TEST 2: Coordinate Space
    // Android Canvas Origin (0,0) is Top-Left.
    // WebGL Origin (0,0) is Bottom-Left.
    // Our transpiler simulates Android.
    // EXPECTED RESULT:
    // Top-Left corner should be BLACK (0,0).
    // Bottom-Left corner should be GREEN (0,1).
    // If Green is at the TOP, the coordinate flip failed.
    float2 uv = coord / iResolution.xy;

    // TEST 3: Missing Intrinsics
    // 'saturate()' exists in AGSL but NOT in GLSL 1.0.
    // Our polyfill must turn this into clamp(x, 0.0, 1.0).
    // EXPECTED RESULT: A pulsing blue channel that never exceeds 1.0 (no artifacts).
    float pulse = saturate(sin(iTime * 3.0) * 2.0);

    // TEST 4: AGSL Types
    // Using 'half4' and 'float2' ensures type mapping is working.
    return half4(uv.x, uv.y, pulse, 1.0) + uBrandColor;
}



// Holographic Star Shader

layout(color) uniform half4 uColor;

half4 main(float2 coord) {
    float2 uv = coord / iResolution.xy;
    float2 center = float2(0.5, 0.5);
    
    float d = distance(uv, center);
    float angle = atan(uv.y - center.y, uv.x - center.x);
    
    float wave = sin(d * 40.0 - iTime * 5.0);
    float spiral = sin(angle * 10.0 + iTime * 2.0);
    
    float holograph = saturate(wave * spiral);
    
    half3 color = half3(uv.x, uv.y, holograph);
    
    return half4(color, 1.0);
}


// Heart path Data
M140 20C73 20 20 74 20 140c0 135 136 170 228 303 88-132 229-173 229-303 0-66-54-120-120-120-48 0-90 28-109 69-19-41-60-69-108-69z

// Star Path Data
M 150 15 L 185 117 L 292 117 L 205 180 L 239 283 L 150 220 L 61 283 L 95 180 L 8 117 L 115 117 Z



// AGSL Coordinate Verification Shader
// -----------------------------------
// PURPOSE: 
// Verify that the WebGL Preview correctly simulates Android's coordinate system.
// Android Canvas Origin (0,0) is Top-Left.
// WebGL Default Origin (0,0) is Bottom-Left.

half4 main(float2 coord) {
    // Normalize coordinates to 0.0 - 1.0
    float2 uv = coord / iResolution.xy;

    // TEST 1: The Origin Check (Green Box)
    // In Android AGSL, (0,0) is the Top-Left corner.
    // IF CORRECT: You will see a GREEN square at the TOP-LEFT.
    // IF BROKEN: You will see a GREEN square at the BOTTOM-LEFT (WebGL default).
    if (uv.x < 0.2 && uv.y < 0.2) {
        return half4(0.0, 1.0, 0.0, 1.0);
    }

    // TEST 2: The Max Extent Check (Red Box)
    // In Android AGSL, (1,1) is the Bottom-Right corner.
    // IF CORRECT: You will see a RED square at the BOTTOM-RIGHT.
    // IF BROKEN: You will see a RED square at the TOP-RIGHT.
    if (uv.x > 0.8 && uv.y > 0.8) {
        return half4(1.0, 0.0, 0.0, 1.0);
    }

    // TEST 3: Y-Axis Direction (Blue Gradient)
    // In Android, Y increases downwards.
    // IF CORRECT: The background is BLACK at the TOP and fades to BLUE at the BOTTOM.
    // IF BROKEN: The background is BLUE at the TOP and fades to BLACK at the BOTTOM.
    return half4(0.0, 0.0, uv.y, 1.0);
}



// skeleton shimmer

layout(color) uniform half4 uBaseColor;
layout(color) uniform half4 uHighlightColor;

half4 main(float2 coord) {
    float2 uv = coord / iResolution.xy;
    
    // Default colors if uniforms aren't set
    half4 base = half4(0.9, 0.9, 0.9, 1.0);
    half4 highlight = half4(1.0, 1.0, 1.0, 1.0);
    
    // Tilted shimmer line
    float position = (uv.x + uv.y * 0.2) - iTime * 1.5;
    position = fract(position);
    
    float shimmer = smoothstep(0.4, 0.5, position) * (1.0 - smoothstep(0.5, 0.6, position));
    
    return mix(base, highlight, shimmer);
}


// rounded rect

half4 main(float2 coord) {
    float2 uv = (coord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float2 size = float2(0.4, 0.3);
    float radius = 0.1;
    
    float2 d = abs(uv) - size + radius;
    float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;
    
    float alpha = 1.0 - smoothstep(0.0, 0.01, dist);
    
    return half4(0.2, 0.6, 1.0, alpha);
}

// color space Check
// Visual Confirmation: The "Linear" side should look darker/richer than the "Raw" side. If they look identical, the functions aren't doing anything.

half4 main(float2 coord) {
    float2 uv = coord / iResolution.xy;
    
    half3 color = half3(uv.x, 0.5, 0.5);
    
    // Left side: Standard sRGB
    if (uv.y < 0.5) {
        return half4(color, 1.0);
    } 
    // Right side: Converted to Linear and back (Should look slightly different)
    else {
        half3 lin = toLinearSrgb(color);
        return half4(fromLinearSrgb(lin), 1.0);
    }
}



// Aurora mesh gradient

layout(color) uniform half4 uColor1;
layout(color) uniform half4 uColor2;
layout(color) uniform half4 uColor3;

half4 main(float2 coord) {
    float2 uv = coord / iResolution.xy;
    
    float t = iTime * 0.5;
    
    // Moving color points
    float2 p1 = float2(0.5 + 0.4*sin(t), 0.5 + 0.3*cos(t*1.2));
    float2 p2 = float2(0.2 + 0.3*cos(t*0.7), 0.8 + 0.2*sin(t*0.9));
    float2 p3 = float2(0.8 + 0.2*sin(t*1.1), 0.2 + 0.3*cos(t*1.3));
    
    float d1 = length(uv - p1);
    float d2 = length(uv - p2);
    float d3 = length(uv - p3);
    
    // Soft radial falloff
    float w1 = smoothstep(0.8, 0.0, d1);
    float w2 = smoothstep(0.8, 0.0, d2);
    float w3 = smoothstep(0.8, 0.0, d3);
    
    // Defaults if uniforms are transparent
    half4 c1 = half4(1.0, 0.2, 0.5, 1.0); // Pink
    half4 c2 = half4(0.2, 0.5, 1.0, 1.0); // Blue
    half4 c3 = half4(0.1, 1.0, 0.6, 1.0); // Green
    half4 bg = half4(0.1, 0.0, 0.2, 1.0); // Dark Purple
    
    half4 col = bg;
    col = mix(col, c1, w1);
    col = mix(col, c2, w2);
    col = mix(col, c3, w3);
    
    return col;
}


// goo balls

half4 main(float2 coord) {
    float2 uv = (coord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    // Circle 1 (Static center)
    float d1 = length(uv);
    
    // Circle 2 (Orbiting)
    float2 orbit = float2(cos(iTime * 1.0), sin(iTime * 3.0)) * 0.3;
    float d2 = length(uv - orbit);
    
    // Smooth Min (The "Gooey" Math)
    // k controls the stickiness distance
    float k = 0.15;
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    float d = mix(d2, d1, h) - k * h * (1.0 - h);
    
    // Threshold
    float alpha = 1.0 - smoothstep(0.1, 0.12, d);
    
    return half4(0.2, 0.8, 1.0, alpha);
}



// TV static noise vignette

// Pseudo-random generator
float random(float2 st) {
    return fract(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

half4 main(float2 coord) {
    float2 uv = coord / iResolution.xy;
    
    // Generate static noise based on coordinate
    // Add iTime to 'uv' inside random() for TV static
    float noise = random(uv * 1.0 * iTime); // Scale up for finer grain
    
    // Soft vignette
    float dist = distance(uv, float2(0.5));
    float vignette = 1.0 - smoothstep(0.3, 0.8, dist);
    
    // Mix noise into a card-like surface
    half3 paperColor = half3(0.96, 0.96, 0.94); // Off-white
    half3 grainColor = half3(0.8, 0.8, 0.8);
    
    // Blend: 95% paper, 5% noise
    half3 finalColor = mix(paperColor, grainColor, noise * 0.5);
    
    return half4(finalColor * vignette, 1.0);
}


// Neon glow

// Simple Gaussian Blur
float blur(float2 uv, float radius) {
    float alpha = 0.0;
    float total = 0.0;
    
    // Sample in a 5x5 grid
    for (float x = -2.0; x <= 2.0; x++) {
        for (float y = -2.0; y <= 2.0; y++) {
            float2 offset = float2(x, y) * radius;
            // Gaussian weight (simple approximation)
            float weight = 1.0 / (1.0 + length(float2(x, y)));
            
            alpha += texture2D(uShapeMask, uv + offset).r * weight;
            total += weight;
        }
    }
    
    return alpha / total;
}

half4 main(float2 coord) {
    float2 uv = coord / iResolution.xy;
    
    // 1. Get the Sharp Shape (The "Core")
    float core = texture2D(uShapeMask, uv).r;
    
    // 2. Get the Blurred Shape (The "Glow")
    // Oscillate radius for a breathing effect
    float radius = 0.005 + 0.005 * sin(iTime * 4.0);
    float glow = blur(uv, radius);
    
    // 3. Composite
    // Core is White, Glow is Pink/Purple
    half3 coreColor = half3(1.0, 1.0, 1.0);
    half3 glowColor = half3(1.0, 0.0, 1.0); // Magenta
    
    // Mix them: Core sits on top of Glow
    half3 finalColor = mix(glowColor * glow * 2.0, coreColor, core);
    
    // Output alpha based on the glow (so empty space is transparent)
    return half4(finalColor, max(core, glow));
}